# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t3k5lRAdyCF9NTwmB-e9BalEStY3FMbv
"""

from flask import Flask, request, jsonify
import joblib
import numpy as np

app = Flask(__name__)

# --- Carregamento do Modelo ---
# Certifique-se que o arquivo .pkl está na mesma pasta que este script
try:
    data = joblib.load('modelo_utlc_apps_sentimento.pkl')
    model = data['model']
    vectorizer = data['vectorizer']
    print(">>> Modelo carregado com sucesso! Servidor pronto.")
except Exception as e:
    print(f">>> Erro crítico ao carregar modelo: {e}")
    model = None
    vectorizer = None

LABEL_MAP = {
    "negative": "Negativo",
    "neutral": "Neutro",
    "positive": "Positivo"
}

@app.route('/predict', methods=['POST'])
def predict():
    try:
        # Se o modelo não carregou, retorna erro logo de cara
        if not model or not vectorizer:
            return jsonify({"erro": "Modelo não está carregado no servidor."}), 500

        dados = request.get_json()
        texto = dados.get('text') if dados else None

        # Validação básica
        if not texto or len(texto.strip()) < 5:
            return jsonify({"erro": "Texto não fornecido ou muito curto."}), 400

        # 1. Transformar o texto
        X = vectorizer.transform([texto])

        # 2. Fazer a previsão
        prediction_label = model.predict(X)[0]
        proba = float(model.predict_proba(X).max())

        # 3. Explicabilidade (Pesos)
        palavras_relevantes = []

        if hasattr(model, 'coef_'):
            feature_names = vectorizer.get_feature_names_out()
            indices_palavras_na_frase = X.nonzero()[1]

            # Descobre o índice da classe prevista
            classe_idx = np.where(model.classes_ == prediction_label)[0][0]

            # Seleciona os pesos corretos (Multiclasse ou Binário)
            if model.coef_.ndim > 1:
                pesos_classe = model.coef_[classe_idx]
            else:
                pesos_classe = model.coef_[0] if classe_idx == 1 else -model.coef_[0]

            # Monta a lista bruta
            for idx in indices_palavras_na_frase:
                peso = pesos_classe[idx]
                palavra = feature_names[idx]
                palavras_relevantes.append({
                    "palavra": palavra,
                    "peso": round(float(peso), 4)
                })

            # Ordena: Maior impacto primeiro
            palavras_relevantes = sorted(palavras_relevantes, key=lambda x: x['peso'], reverse=True)

            # --- CORTE RÍGIDO (TOP 5) ---
            if len(palavras_relevantes) > 5:
                palavras_relevantes = palavras_relevantes[:5]

        # Retorno final
        return jsonify({
            "previsao": LABEL_MAP.get(prediction_label, "Desconhecido"),
            "probabilidade": round(proba, 2),
            "analise_pesos": palavras_relevantes
        })

    except Exception as e:
        # Log do erro no terminal do servidor para debug
        print(f"Erro na requisição: {e}")
        return jsonify({"erro": str(e)}), 500

# --- Bloco de Inicialização do Servidor ---
if __name__ == '__main__':
    # host='0.0.0.0' permite acesso externo
    # debug=False é mais seguro para produção (evita mostrar código fonte no erro)
    app.run(host="0.0.0.0", port=5000, debug=False)